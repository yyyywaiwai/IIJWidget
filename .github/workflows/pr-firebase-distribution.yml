name: PR Firebase Distribution

on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

concurrency:
  group: pr-firebase-distribution-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read

env:
  PROJECT: IIJWidget.xcodeproj
  SCHEME: IIJWidget
  BUNDLE_ID: jp.yyyywaiwai.IIJWidget
  WIDGET_BUNDLE_ID: jp.yyyywaiwai.IIJWidget.RemainingDataWidget
  EXPORT_METHOD: development
  CODE_SIGN_STYLE: automatic
  CODE_SIGN_IDENTITY: Apple Distribution

jobs:
  build:
    name: Build IPA
    if: ${{ github.event.pull_request.draft == false }}
    runs-on: macos-15
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Prepare build paths
        run: |
          echo "ARCHIVE_PATH=$RUNNER_TEMP/IIJWidget.xcarchive" >> "$GITHUB_ENV"
          echo "EXPORT_PATH=$RUNNER_TEMP/export" >> "$GITHUB_ENV"

      - name: Select Xcode 26.0
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '26.0'

      - name: Resolve Swift package dependencies
        run: xcodebuild -project "$PROJECT" -scheme "$SCHEME" -resolvePackageDependencies

      - name: Create export options
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          EXPORT_OPTIONS_PLIST="$RUNNER_TEMP/exportOptions.plist"
          cat <<EOF2 > "$EXPORT_OPTIONS_PLIST"
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
            <dict>
              <key>compileBitcode</key>
              <false/>
              <key>destination</key>
              <string>export</string>
              <key>method</key>
              <string>$EXPORT_METHOD</string>
              <key>manageAppVersionAndBuildNumber</key>
              <false/>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>stripSwiftSymbols</key>
              <true/>
              <key>teamID</key>
              <string>$TEAM_ID</string>
            </dict>
          </plist>
          EOF2
          echo "EXPORT_OPTIONS_PLIST=$EXPORT_OPTIONS_PLIST" >> "$GITHUB_ENV"

      - name: Prepare App Store Connect API key
        env:
          ASC_API_KEY_P8: ${{ secrets.ASC_API_KEY_P8 }}
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_KEY_ISSUER_ID: ${{ secrets.ASC_API_KEY_ISSUER_ID }}
        run: |
          set -euo pipefail
          if [ -z "$ASC_API_KEY_P8" ] || [ -z "$ASC_API_KEY_ID" ] || [ -z "$ASC_API_KEY_ISSUER_ID" ]; then
            echo 'App Store Connect API key secrets are missing' >&2
            exit 1
          fi
          ASC_KEY_PATH="$RUNNER_TEMP/AuthKey.p8"
          echo "$ASC_API_KEY_P8" | base64 --decode > "$ASC_KEY_PATH"
          chmod 600 "$ASC_KEY_PATH"
          {
            echo "ASC_KEY_PATH=$ASC_KEY_PATH"
            echo "ASC_KEY_ID=$ASC_API_KEY_ID"
            echo "ASC_ISSUER_ID=$ASC_API_KEY_ISSUER_ID"
          } >> "$GITHUB_ENV"

      - name: Revoke stale distribution certificates
        env:
          ASC_KEY_PATH: ${{ env.ASC_KEY_PATH }}
          ASC_KEY_ID: ${{ env.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ env.ASC_ISSUER_ID }}
          ASC_PROTECTED_CERT_SERIALS: ${{ secrets.ASC_PROTECTED_CERT_SERIALS }}
          ASC_PROTECTED_CERT_NAMES: ${{ secrets.ASC_PROTECTED_CERT_NAMES }}
        run: |
          set -euo pipefail
          if [ -z "$ASC_KEY_PATH" ] || [ -z "$ASC_KEY_ID" ] || [ -z "$ASC_ISSUER_ID" ]; then
            echo 'App Store Connect API key configuration is missing' >&2
            exit 1
          fi
          pip3 install --disable-pip-version-check --no-cache-dir 'pyjwt[crypto]' >/dev/null
          python3 <<'PY'
import datetime
import json
import os
import sys
import time
import urllib.error
import urllib.parse
import urllib.request

try:
    import jwt  # type: ignore
except ModuleNotFoundError as exc:  # pragma: no cover
    raise SystemExit(f"Failed to import pyjwt: {exc}")

ASC_KEY_PATH = os.environ['ASC_KEY_PATH']
ASC_KEY_ID = os.environ['ASC_KEY_ID']
ASC_ISSUER_ID = os.environ['ASC_ISSUER_ID']
API_BASE = 'https://api.appstoreconnect.apple.com'
CERTIFICATE_LIMIT = 3
CERTIFICATES_TO_KEEP = 2


def parse_protected(value: str) -> list[str]:
    value = value.strip()
    if not value:
        return []
    try:
        parsed = json.loads(value)
    except json.JSONDecodeError:
        items = value.replace('\n', ',').split(',')
        return [item.strip() for item in items if item.strip()]
    if isinstance(parsed, list):
        return [str(item).strip() for item in parsed if str(item).strip()]
    if isinstance(parsed, str):
        return [parsed.strip()] if parsed.strip() else []
    raise SystemExit('ASC_PROTECTED_CERT_* must be JSON array, string, or comma/newline separated list')


PROTECTED_SERIALS = set(parse_protected(os.environ.get('ASC_PROTECTED_CERT_SERIALS', '')))
PROTECTED_NAMES = set(parse_protected(os.environ.get('ASC_PROTECTED_CERT_NAMES', '')))

with open(ASC_KEY_PATH, 'r', encoding='utf-8') as fh:
    private_key = fh.read()

payload = {
    'iss': ASC_ISSUER_ID,
    'exp': int(time.time()) + 600,
    'aud': 'appstoreconnect-v1',
}

token = jwt.encode(payload, private_key, algorithm='ES256', headers={'kid': ASC_KEY_ID})

def request(method: str, path: str, *, data: dict | None = None) -> dict | None:
    url = urllib.parse.urljoin(API_BASE, path)
    req = urllib.request.Request(url, method=method)
    req.add_header('Authorization', f'Bearer {token}')
    if data is not None:
        body = json.dumps(data).encode('utf-8')
        req.add_header('Content-Type', 'application/json')
        req.data = body
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            if resp.status == 204:
                return None
            return json.loads(resp.read().decode('utf-8'))
    except urllib.error.HTTPError as error:  # pragma: no cover - surfaced to workflow log
        message = error.read().decode('utf-8', errors='ignore')
        raise SystemExit(f'App Store Connect API request failed ({error.code}): {message}')


response = request('GET', '/v1/certificates?filter[type]=IOS_DISTRIBUTION&fields[certificates]=name,serialNumber,expirationDate,certificateType,dateCreated')
if response is None:
    sys.exit(0)

certificates = response.get('data', [])
distribution = [c for c in certificates if c.get('attributes', {}).get('certificateType') == 'IOS_DISTRIBUTION']

if len(distribution) < CERTIFICATE_LIMIT:
    print('Distribution certificate count below limit; no revocation necessary.')
    sys.exit(0)

def sort_key(item: dict) -> tuple[datetime.datetime, str]:
    created_at = item.get('attributes', {}).get('dateCreated', '')
    serial = item.get('attributes', {}).get('serialNumber', '')
    try:
        timestamp = datetime.datetime.fromisoformat(created_at.replace('Z', '+00:00'))
    except ValueError:
        timestamp = datetime.datetime.min
    return (timestamp, serial)

distribution.sort(key=sort_key)
candidates: list[dict] = []
protected_seen = 0

for certificate in distribution:
    attributes = certificate.get('attributes', {})
    name = attributes.get('name', '')
    serial = attributes.get('serialNumber', '')
    if serial in PROTECTED_SERIALS or name in PROTECTED_NAMES:
        protected_seen += 1
        print(f"Skipping protected certificate '{name or 'unknown'}' (serial {serial or 'unknown'}).")
        continue
    candidates.append(certificate)

excess = max(0, len(distribution) - CERTIFICATES_TO_KEEP)

if excess == 0:
    print('Certificate count already within retention limit; nothing to revoke.')
    sys.exit(0)

if not candidates:
    raise SystemExit('Certificate limit exceeded but no revocable certificates remain after applying protection rules.')

to_revoke = candidates[:excess]

if len(to_revoke) < excess:
    raise SystemExit('Certificate limit exceeded and protected certificates prevent automatic cleanup. Please revoke manually.')

for certificate in to_revoke:
    cert_id = certificate['id']
    attributes = certificate.get('attributes', {})
    name = attributes.get('name', 'unknown')
    serial = attributes.get('serialNumber', 'unknown')
    expiration = attributes.get('expirationDate', 'unknown')
    request('DELETE', f'/v1/certificates/{cert_id}')
    print(f"Revoked certificate '{name}' (serial {serial}, expires {expiration}).")

remaining = len(distribution) - len(to_revoke)
print(f'Remaining distribution certificates after cleanup: {remaining} (protected: {protected_seen}).')
PY

      - name: Archive IIJWidget
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -o pipefail
          xcodebuild \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            -destination 'generic/platform=iOS' \
            -allowProvisioningUpdates \
            -authenticationKeyPath "$ASC_KEY_PATH" \
            -authenticationKeyID "$ASC_KEY_ID" \
            -authenticationKeyIssuerID "$ASC_ISSUER_ID" \
            clean archive

      - name: Export IPA
        run: |
          set -o pipefail
          mkdir -p "$EXPORT_PATH"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PLIST" \
            -allowProvisioningUpdates \
            -authenticationKeyPath "$ASC_KEY_PATH" \
            -authenticationKeyID "$ASC_KEY_ID" \
            -authenticationKeyIssuerID "$ASC_ISSUER_ID"

      - name: Locate IPA
        id: ipa
        run: |
          IPA_PATH=$(find "$EXPORT_PATH" -type f -name '*.ipa' | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'IPA file not found' >&2
            exit 1
          fi
          echo "path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: pr-ipa
          path: ${{ steps.ipa.outputs.path }}
          if-no-files-found: error

  distribute:
    name: Firebase Upload & Discord
    if: ${{ github.event.pull_request.draft == false }}
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Download IPA artifact
        uses: actions/download-artifact@v4
        with:
          name: pr-ipa
          path: ./dist

      - name: Locate IPA
        id: ipa
        run: |
          set -euo pipefail
          IPA_PATH=$(find ./dist -maxdepth 2 -type f -name '*.ipa' | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'Downloaded IPA not found' >&2
            exit 1
          fi
          echo "path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Ensure Firebase credentials exist
        run: |
          if [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
            echo 'FIREBASE_SERVICE_ACCOUNT is empty. Is this run from a fork?' >&2
            exit 1
          fi

      - name: Upload to Firebase App Distribution
        id: firebase
        uses: wzieba/Firebase-Distribution-Github-Action@v1.7.1
        with:
          appId: ${{ secrets.FIREBASE_APP_ID }}
          serviceCredentialsFileContent: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          groups: ${{ secrets.FIREBASE_DISTRIBUTION_GROUPS }}
          testers: ${{ secrets.FIREBASE_DISTRIBUTION_TESTERS }}
          file: ${{ steps.ipa.outputs.path }}
          releaseNotes: |
            PR #${{ github.event.pull_request.number }} · ${{ github.event.pull_request.title }}
            Author: ${{ github.event.pull_request.user.login }}
            Commit: ${{ github.sha }}

      - name: Notify Discord
        if: ${{ success() }}
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          RELEASE_URL: ${{ steps.firebase.outputs.FIREBASE_CONSOLE_URI }}
          DOWNLOAD_URL: ${{ steps.firebase.outputs.TESTING_URI }}
          BINARY_URL: ${{ steps.firebase.outputs.BINARY_DOWNLOAD_URI }}
        run: |
          set -euo pipefail
          if [ -z "$WEBHOOK_URL" ]; then
            echo 'Discord webhook URL is not configured' >&2
            exit 1
          fi
          LINK="$RELEASE_URL"
          if [ -z "$LINK" ]; then
            LINK="$DOWNLOAD_URL"
          fi
          if [ -z "$LINK" ]; then
            LINK="$BINARY_URL"
          fi
          if [ -z "$LINK" ]; then
            echo 'Firebase action did not return a release link' >&2
            exit 1
          fi
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          COMMIT_SHA="${{ github.sha }}"
          AUTHOR="${{ github.event.pull_request.user.login }}"
          PAYLOAD=$(jq -n \
            --arg link "$LINK" \
            --arg pr "#$PR_NUMBER · $PR_TITLE" \
            --arg commit "$COMMIT_SHA" \
            --arg author "$AUTHOR" \
            '{
              embeds: [
                {
                  title: "新しい PR ビルドが利用可能",
                  description: "[Install build](\($link))",
                  color: 5793266,
                  fields: [
                    {name: "PR", value: $pr},
                    {name: "Commit", value: $commit},
                    {name: "Author", value: $author}
                  ],
                  footer: {text: "Firebase App Distribution"}
                }
              ]
            }')
          curl -X POST -H 'Content-Type: application/json' -d "$PAYLOAD" "$WEBHOOK_URL"
