name: PR Firebase Distribution

on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
  workflow_dispatch:

concurrency:
  group: pr-firebase-distribution-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read

env:
  PROJECT: IIJWidget.xcodeproj
  SCHEME: IIJWidget
  BUNDLE_ID: jp.yyyywaiwai.IIJWidget
  WIDGET_BUNDLE_ID: jp.yyyywaiwai.IIJWidget.RemainingDataWidget
  EXPORT_METHOD: development
  CODE_SIGN_STYLE: automatic
  CODE_SIGN_IDENTITY: Apple Distribution

jobs:
  build:
    name: Build IPA
    if: ${{ github.event.pull_request.draft != true }}
    runs-on: macos-15
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Prepare build paths
        run: |
          echo "ARCHIVE_PATH=$RUNNER_TEMP/IIJWidget.xcarchive" >> "$GITHUB_ENV"
          echo "EXPORT_PATH=$RUNNER_TEMP/export" >> "$GITHUB_ENV"

      - name: Select Xcode 26.0
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '26.0'

      - name: Resolve Swift package dependencies
        run: xcodebuild -project "$PROJECT" -scheme "$SCHEME" -resolvePackageDependencies

      - name: Setup signing certificate and provisioning profiles
        env:
          CERTIFICATE_P12: ${{ secrets.DISTRIBUTION_CERTIFICATE_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.DISTRIBUTION_CERTIFICATE_PASSWORD }}
          PROVISIONING_PROFILE_APP: ${{ secrets.PROVISIONING_PROFILE_APP_DEV }}
          PROVISIONING_PROFILE_WIDGET: ${{ secrets.PROVISIONING_PROFILE_WIDGET_DEV }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
          CERT_PATH="$RUNNER_TEMP/certificate.p12"

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Decode and import certificate
          echo "$CERTIFICATE_P12" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"
          rm -f "$CERT_PATH"

          # Add keychain to search list and set as default
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')
          security default-keychain -s "$KEYCHAIN_PATH"

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find certificate identity
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Apple Distribution" | head -1 | awk -F'"' '{print $2}')
          if [ -z "$IDENTITY" ]; then
            echo "No valid signing identity found" >&2
            exit 1
          fi
          echo "Using signing identity: $IDENTITY"

          # Install provisioning profiles
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILES_DIR"

          # Decode profiles to temp files first
          APP_PROFILE_TMP="$RUNNER_TEMP/app_profile.mobileprovision"
          WIDGET_PROFILE_TMP="$RUNNER_TEMP/widget_profile.mobileprovision"
          echo "$PROVISIONING_PROFILE_APP" | base64 --decode > "$APP_PROFILE_TMP"
          echo "$PROVISIONING_PROFILE_WIDGET" | base64 --decode > "$WIDGET_PROFILE_TMP"

          # Extract UUIDs and names, then install with UUID filename
          APP_PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(/usr/bin/security cms -D -i "$APP_PROFILE_TMP"))
          APP_PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin <<< $(/usr/bin/security cms -D -i "$APP_PROFILE_TMP"))
          cp "$APP_PROFILE_TMP" "$PROFILES_DIR/$APP_PROFILE_UUID.mobileprovision"

          WIDGET_PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(/usr/bin/security cms -D -i "$WIDGET_PROFILE_TMP"))
          WIDGET_PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin <<< $(/usr/bin/security cms -D -i "$WIDGET_PROFILE_TMP"))
          cp "$WIDGET_PROFILE_TMP" "$PROFILES_DIR/$WIDGET_PROFILE_UUID.mobileprovision"

          echo "App profile: $APP_PROFILE_NAME"
          echo "Widget profile: $WIDGET_PROFILE_NAME"

          {
            echo "KEYCHAIN_PATH=$KEYCHAIN_PATH"
            echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD"
            echo "CODE_SIGN_IDENTITY=$IDENTITY"
            echo "APP_PROFILE_NAME=$APP_PROFILE_NAME"
            echo "WIDGET_PROFILE_NAME=$WIDGET_PROFILE_NAME"
          } >> "$GITHUB_ENV"

      - name: Create export options
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          EXPORT_OPTIONS_PLIST="$RUNNER_TEMP/exportOptions.plist"
          cat <<EOF2 > "$EXPORT_OPTIONS_PLIST"
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
            <dict>
              <key>compileBitcode</key>
              <false/>
              <key>destination</key>
              <string>export</string>
              <key>method</key>
              <string>$EXPORT_METHOD</string>
              <key>manageAppVersionAndBuildNumber</key>
              <false/>
              <key>signingStyle</key>
              <string>manual</string>
              <key>signingCertificate</key>
              <string>$CODE_SIGN_IDENTITY</string>
              <key>stripSwiftSymbols</key>
              <true/>
              <key>teamID</key>
              <string>$TEAM_ID</string>
              <key>provisioningProfiles</key>
              <dict>
                <key>$BUNDLE_ID</key>
                <string>$APP_PROFILE_NAME</string>
                <key>$WIDGET_BUNDLE_ID</key>
                <string>$WIDGET_PROFILE_NAME</string>
              </dict>
            </dict>
          </plist>
          EOF2
          echo "EXPORT_OPTIONS_PLIST=$EXPORT_OPTIONS_PLIST" >> "$GITHUB_ENV"

      - name: Configure manual signing in project
        run: |
          set -euo pipefail
          PBXPROJ="$PROJECT/project.pbxproj"

          # Create a Ruby script to update the project file
          cat > "$RUNNER_TEMP/update_signing.rb" << 'RUBY'
          require 'xcodeproj'

          project_path = ARGV[0]
          app_profile = ARGV[1]
          widget_profile = ARGV[2]
          code_sign_identity = ARGV[3]

          project = Xcodeproj::Project.open(project_path)

          project.targets.each do |target|
            target.build_configurations.each do |config|
              config.build_settings['CODE_SIGN_STYLE'] = 'Manual'
              config.build_settings['CODE_SIGN_IDENTITY'] = code_sign_identity
              config.build_settings['CODE_SIGN_IDENTITY[sdk=iphoneos*]'] = code_sign_identity

              if target.name == 'IIJWidget'
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = app_profile
              elsif target.name == 'RemainingDataWidget'
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = widget_profile
              end
            end
          end

          project.save
          puts "Project updated successfully"
          RUBY

          gem install xcodeproj --no-document
          ruby "$RUNNER_TEMP/update_signing.rb" "$PROJECT" "$APP_PROFILE_NAME" "$WIDGET_PROFILE_NAME" "$CODE_SIGN_IDENTITY"

      - name: Archive IIJWidget
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -o pipefail
          xcodebuild \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            -destination 'generic/platform=iOS' \
            clean archive

      - name: Export IPA
        run: |
          set -o pipefail
          mkdir -p "$EXPORT_PATH"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PLIST"

      - name: Locate IPA
        id: ipa
        run: |
          IPA_PATH=$(find "$EXPORT_PATH" -type f -name '*.ipa' | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'IPA file not found' >&2
            exit 1
          fi
          echo "path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: pr-ipa
          path: ${{ steps.ipa.outputs.path }}
          if-no-files-found: error

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

  distribute:
    name: Firebase Upload & Discord
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.draft == false }}
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Download IPA artifact
        uses: actions/download-artifact@v4
        with:
          name: pr-ipa
          path: ./dist

      - name: Locate IPA
        id: ipa
        run: |
          set -euo pipefail
          IPA_PATH=$(find ./dist -maxdepth 2 -type f -name '*.ipa' | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'Downloaded IPA not found' >&2
            exit 1
          fi
          echo "path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Compose release notes
        id: release_notes
        run: |
          set -euo pipefail
          NOTES_PATH="$GITHUB_WORKSPACE/release-notes.txt"
          PR_NUMBER=$(jq -r '.pull_request.number // empty' "$GITHUB_EVENT_PATH")
          PR_TITLE=$(jq -r '.pull_request.title // empty' "$GITHUB_EVENT_PATH")
          PR_AUTHOR=$(jq -r '.pull_request.user.login // empty' "$GITHUB_EVENT_PATH")
          if [ -n "$PR_NUMBER" ] && [ -n "$PR_TITLE" ]; then
            {
              echo "PR #$PR_NUMBER · $PR_TITLE"
              echo "Author: $PR_AUTHOR"
              echo "Commit: $GITHUB_SHA"
            } > "$NOTES_PATH"
          else
            {
              echo "Manual trigger on $GITHUB_REF"
              echo "Actor: $GITHUB_ACTOR"
              echo "Commit: $GITHUB_SHA"
            } > "$NOTES_PATH"
          fi
          echo "path=$NOTES_PATH" >> "$GITHUB_OUTPUT"

      - name: Ensure Firebase credentials exist
        run: |
          if [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
            echo 'FIREBASE_SERVICE_ACCOUNT is empty. Is this run from a fork?' >&2
            exit 1
          fi

      - name: Upload to Firebase App Distribution
        id: firebase
        uses: wzieba/Firebase-Distribution-Github-Action@v1.7.1
        with:
          appId: ${{ secrets.FIREBASE_APP_ID }}
          serviceCredentialsFileContent: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          groups: ${{ secrets.FIREBASE_DISTRIBUTION_GROUPS }}
          testers: ${{ secrets.FIREBASE_DISTRIBUTION_TESTERS }}
          file: ${{ steps.ipa.outputs.path }}
          releaseNotesFile: ${{ steps.release_notes.outputs.path }}

      - name: Notify Discord
        if: ${{ success() }}
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          RELEASE_URL: ${{ steps.firebase.outputs.FIREBASE_CONSOLE_URI }}
          DOWNLOAD_URL: ${{ steps.firebase.outputs.TESTING_URI }}
          BINARY_URL: ${{ steps.firebase.outputs.BINARY_DOWNLOAD_URI }}
        run: |
          set -euo pipefail
          if [ -z "$WEBHOOK_URL" ]; then
            echo 'Discord webhook URL is not configured' >&2
            exit 1
          fi
          LINK="$RELEASE_URL"
          if [ -z "$LINK" ]; then
            LINK="$DOWNLOAD_URL"
          fi
          if [ -z "$LINK" ]; then
            LINK="$BINARY_URL"
          fi
          if [ -z "$LINK" ]; then
            echo 'Firebase action did not return a release link' >&2
            exit 1
          fi
          PR_NUMBER=$(jq -r '.pull_request.number // empty' "$GITHUB_EVENT_PATH")
          PR_TITLE=$(jq -r '.pull_request.title // empty' "$GITHUB_EVENT_PATH")
          PR_AUTHOR=$(jq -r '.pull_request.user.login // empty' "$GITHUB_EVENT_PATH")
          if [ -n "$PR_NUMBER" ] && [ -n "$PR_TITLE" ]; then
            EMBED_TITLE="新しい PR ビルドが利用可能"
            EMBED_FIELDS=$(jq -n \
              --arg pr "#$PR_NUMBER · $PR_TITLE" \
              --arg commit "$GITHUB_SHA" \
              --arg author "$PR_AUTHOR" \
              '[
                {name: "PR", value: $pr},
                {name: "Commit", value: $commit},
                {name: "Author", value: $author}
              ]')
          else
            EMBED_TITLE="手動トリガーのビルドが利用可能"
            EMBED_FIELDS=$(jq -n \
              --arg ref "$GITHUB_REF" \
              --arg commit "$GITHUB_SHA" \
              --arg actor "$GITHUB_ACTOR" \
              '[
                {name: "Ref", value: $ref},
                {name: "Commit", value: $commit},
                {name: "Actor", value: $actor}
              ]')
          fi
          PAYLOAD=$(jq -n \
            --arg link "$LINK" \
            --arg title "$EMBED_TITLE" \
            --argjson fields "$EMBED_FIELDS" \
            '{
              embeds: [
                {
                  title: $title,
                  description: "[Install build](\($link))",
                  color: 5793266,
                  fields: $fields,
                  footer: {text: "Firebase App Distribution"}
                }
              ]
            }')
          curl -X POST -H 'Content-Type: application/json' -d "$PAYLOAD" "$WEBHOOK_URL"
