name: Release TestFlight

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: release-testflight-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  PROJECT: IIJWidget.xcodeproj
  SCHEME: IIJWidget
  BUNDLE_ID: jp.yyyywaiwai.IIJWidget
  WIDGET_BUNDLE_ID: jp.yyyywaiwai.IIJWidget.RemainingDataWidget
  EXPORT_METHOD: app-store

jobs:
  build-and-upload:
    name: Build & Upload to TestFlight
    runs-on: macos-15
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Prepare build paths
        run: |
          echo "ARCHIVE_PATH=$RUNNER_TEMP/IIJWidget.xcarchive" >> "$GITHUB_ENV"
          echo "EXPORT_PATH=$RUNNER_TEMP/export" >> "$GITHUB_ENV"

      - name: Select Xcode 26.0
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '26.0'

      - name: Resolve Swift package dependencies
        run: xcodebuild -project "$PROJECT" -scheme "$SCHEME" -resolvePackageDependencies

      - name: Setup signing certificate and provisioning profiles
        env:
          CERTIFICATE_P12: ${{ secrets.DISTRIBUTION_CERTIFICATE_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.DISTRIBUTION_CERTIFICATE_PASSWORD }}
          PROVISIONING_PROFILE_APP: ${{ secrets.PROVISIONING_PROFILE_APP_APPSTORE }}
          PROVISIONING_PROFILE_WIDGET: ${{ secrets.PROVISIONING_PROFILE_WIDGET_APPSTORE }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
          CERT_PATH="$RUNNER_TEMP/certificate.p12"

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Decode and import certificate
          echo "$CERTIFICATE_P12" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"
          rm -f "$CERT_PATH"

          # Add keychain to search list and set as default
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')
          security default-keychain -s "$KEYCHAIN_PATH"

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find certificate identity
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Apple Distribution" | head -1 | awk -F'"' '{print $2}')
          if [ -z "$IDENTITY" ]; then
            echo "No valid signing identity found" >&2
            exit 1
          fi
          echo "Using signing identity: $IDENTITY"

          # Install provisioning profiles
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILES_DIR"

          # Decode profiles to temp files first
          APP_PROFILE_TMP="$RUNNER_TEMP/app_profile.mobileprovision"
          WIDGET_PROFILE_TMP="$RUNNER_TEMP/widget_profile.mobileprovision"
          echo "$PROVISIONING_PROFILE_APP" | base64 --decode > "$APP_PROFILE_TMP"
          echo "$PROVISIONING_PROFILE_WIDGET" | base64 --decode > "$WIDGET_PROFILE_TMP"

          # Extract UUIDs and names, then install with UUID filename
          APP_PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(/usr/bin/security cms -D -i "$APP_PROFILE_TMP"))
          APP_PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin <<< $(/usr/bin/security cms -D -i "$APP_PROFILE_TMP"))
          cp "$APP_PROFILE_TMP" "$PROFILES_DIR/$APP_PROFILE_UUID.mobileprovision"

          WIDGET_PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(/usr/bin/security cms -D -i "$WIDGET_PROFILE_TMP"))
          WIDGET_PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin <<< $(/usr/bin/security cms -D -i "$WIDGET_PROFILE_TMP"))
          cp "$WIDGET_PROFILE_TMP" "$PROFILES_DIR/$WIDGET_PROFILE_UUID.mobileprovision"

          echo "App profile: $APP_PROFILE_NAME"
          echo "Widget profile: $WIDGET_PROFILE_NAME"

          {
            echo "KEYCHAIN_PATH=$KEYCHAIN_PATH"
            echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD"
            echo "CODE_SIGN_IDENTITY=$IDENTITY"
            echo "APP_PROFILE_NAME=$APP_PROFILE_NAME"
            echo "WIDGET_PROFILE_NAME=$WIDGET_PROFILE_NAME"
          } >> "$GITHUB_ENV"

      - name: Extract version information
        id: version
        run: |
          set -euo pipefail
          SETTINGS_FILE="$(mktemp)"
          trap 'rm -f "$SETTINGS_FILE"' EXIT
          xcodebuild -project "$PROJECT" -scheme "$SCHEME" -configuration Release -showBuildSettings > "$SETTINGS_FILE"
          get_setting () {
            local key="$1"
            awk -F ' = ' -v target="$key" '$1 ~ ("^[[:space:]]*" target "[[:space:]]*$") {gsub(/"/,"",$2); print $2; exit}' "$SETTINGS_FILE"
          }
          APP_VERSION="$(get_setting MARKETING_VERSION || true)"
          BUILD_NUMBER="$(get_setting CURRENT_PROJECT_VERSION || true)"
          if [ -z "$APP_VERSION" ] || [ -z "$BUILD_NUMBER" ]; then
            INFO_PLIST=$(grep -m1 'INFOPLIST_FILE' "$SETTINGS_FILE" | sed 's/^[[:space:]]*INFOPLIST_FILE[[:space:]]*=[[:space:]]*//')
            if [ -z "$INFO_PLIST" ]; then
              echo 'Unable to determine Info.plist path and version keys are missing' >&2
              exit 1
            fi
            case "$INFO_PLIST" in
              /*) ;;
              *) INFO_PLIST="$GITHUB_WORKSPACE/$INFO_PLIST" ;;
            esac
            if [ -z "$APP_VERSION" ]; then
              APP_VERSION=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$INFO_PLIST" 2>/dev/null || true)
            fi
            if [ -z "$BUILD_NUMBER" ]; then
              BUILD_NUMBER=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$INFO_PLIST" 2>/dev/null || true)
            fi
          fi
          if [ -z "$APP_VERSION" ]; then
            APP_VERSION="1.0"
          fi
          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER=1
          fi
          RUN_NUMBER="${GITHUB_RUN_NUMBER:-1}"
          if ! [[ "$RUN_NUMBER" =~ ^[0-9]+$ ]] || [ "$RUN_NUMBER" -lt 1 ]; then
            RUN_NUMBER=1
          fi
          if ! [[ "$BUILD_NUMBER" =~ ^[0-9]+$ ]]; then
            BUILD_NUMBER=1
          fi
          NEW_BUILD_NUMBER=$((BUILD_NUMBER + RUN_NUMBER))
          {
            echo "MARKETING_VERSION_OVERRIDE=$APP_VERSION"
            echo "BUILD_NUMBER_OVERRIDE=$NEW_BUILD_NUMBER"
          } >> "$GITHUB_ENV"
          {
            echo "version=$APP_VERSION"
            echo "build=$NEW_BUILD_NUMBER"
          } >> "$GITHUB_OUTPUT"

      - name: Create export options
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          if [ -z "$TEAM_ID" ]; then
            echo 'APPLE_TEAM_ID secret is missing' >&2
            exit 1
          fi
          EXPORT_OPTIONS_PLIST="$RUNNER_TEMP/exportOptions.plist"
          cat <<EOF2 > "$EXPORT_OPTIONS_PLIST"
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
            <dict>
              <key>compileBitcode</key>
              <false/>
              <key>destination</key>
              <string>export</string>
              <key>method</key>
              <string>$EXPORT_METHOD</string>
              <key>manageAppVersionAndBuildNumber</key>
              <false/>
              <key>signingStyle</key>
              <string>manual</string>
              <key>signingCertificate</key>
              <string>$CODE_SIGN_IDENTITY</string>
              <key>stripSwiftSymbols</key>
              <true/>
              <key>teamID</key>
              <string>$TEAM_ID</string>
              <key>uploadSymbols</key>
              <true/>
              <key>provisioningProfiles</key>
              <dict>
                <key>$BUNDLE_ID</key>
                <string>$APP_PROFILE_NAME</string>
                <key>$WIDGET_BUNDLE_ID</key>
                <string>$WIDGET_PROFILE_NAME</string>
              </dict>
            </dict>
          </plist>
          EOF2
          echo "EXPORT_OPTIONS_PLIST=$EXPORT_OPTIONS_PLIST" >> "$GITHUB_ENV"

      - name: Prepare App Store Connect API key
        id: asc_key
        env:
          ASC_API_KEY_P8: ${{ secrets.ASC_API_KEY_P8 }}
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_KEY_ISSUER_ID: ${{ secrets.ASC_API_KEY_ISSUER_ID }}
        run: |
          set -euo pipefail
          if [ -z "$ASC_API_KEY_P8" ] || [ -z "$ASC_API_KEY_ID" ] || [ -z "$ASC_API_KEY_ISSUER_ID" ]; then
            echo 'App Store Connect API key secrets are missing' >&2
            exit 1
          fi
          ASC_KEY_PATH="$RUNNER_TEMP/AuthKey.p8"
          echo "$ASC_API_KEY_P8" | base64 --decode > "$ASC_KEY_PATH"
          chmod 600 "$ASC_KEY_PATH"
          KEY_CONTENT=$(cat "$ASC_KEY_PATH")
          echo "::add-mask::$KEY_CONTENT"
          {
            echo "ASC_KEY_PATH=$ASC_KEY_PATH"
            echo "ASC_KEY_ID=$ASC_API_KEY_ID"
            echo "ASC_ISSUER_ID=$ASC_API_KEY_ISSUER_ID"
          } >> "$GITHUB_ENV"
          {
            echo "key_id=$ASC_API_KEY_ID"
            echo "issuer_id=$ASC_API_KEY_ISSUER_ID"
            echo "key<<EOF"
            printf '%s\n' "$KEY_CONTENT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Configure manual signing in project
        run: |
          set -euo pipefail

          # Create a Ruby script to update the project file
          cat > "$RUNNER_TEMP/update_signing.rb" << 'RUBY'
          require 'xcodeproj'

          project_path = ARGV[0]
          app_profile = ARGV[1]
          widget_profile = ARGV[2]
          code_sign_identity = ARGV[3]

          project = Xcodeproj::Project.open(project_path)

          project.targets.each do |target|
            target.build_configurations.each do |config|
              config.build_settings['CODE_SIGN_STYLE'] = 'Manual'
              config.build_settings['CODE_SIGN_IDENTITY'] = code_sign_identity
              config.build_settings['CODE_SIGN_IDENTITY[sdk=iphoneos*]'] = code_sign_identity

              if target.name == 'IIJWidget'
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = app_profile
              elsif target.name == 'RemainingDataWidget'
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = widget_profile
              end
            end
          end

          project.save
          puts "Project updated successfully"
          RUBY

          gem install xcodeproj --no-document
          ruby "$RUNNER_TEMP/update_signing.rb" "$PROJECT" "$APP_PROFILE_NAME" "$WIDGET_PROFILE_NAME" "$CODE_SIGN_IDENTITY"

      - name: Archive IIJWidget
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -o pipefail
          xcodebuild \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            -destination 'generic/platform=iOS' \
            MARKETING_VERSION="$MARKETING_VERSION_OVERRIDE" \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER_OVERRIDE" \
            clean archive

      - name: Export IPA
        run: |
          set -o pipefail
          mkdir -p "$EXPORT_PATH"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PLIST" \
            -exportPath "$EXPORT_PATH"

      - name: Locate IPA
        id: ipa
        run: |
          set -euo pipefail
          IPA_PATH=$(find "$EXPORT_PATH" -maxdepth 2 -type f -name '*.ipa' | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'Exported IPA not found' >&2
            exit 1
          fi
          echo "path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: testflight-ipa
          path: ${{ steps.ipa.outputs.path }}

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v3
        with:
          app-path: ${{ steps.ipa.outputs.path }}
          issuer-id: ${{ steps.asc_key.outputs.issuer_id }}
          api-key-id: ${{ steps.asc_key.outputs.key_id }}
          api-private-key: ${{ steps.asc_key.outputs.key }}

      - name: Notify Discord
        if: ${{ success() }}
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TESTFLIGHT_PUBLIC_LINK: ${{ secrets.TESTFLIGHT_PUBLIC_LINK }}
        run: |
          set -euo pipefail
          if [ -z "$WEBHOOK_URL" ]; then
            echo 'Discord webhook URL is not configured' >&2
            exit 1
          fi
          RUN_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
          COMMIT_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA"
          COMMIT_SHORT=${GITHUB_SHA:0:7}
           VERSION="${{ steps.version.outputs.version }}"
           BUILD="${{ steps.version.outputs.build }}"
          if [ -z "$VERSION" ] || [ -z "$BUILD" ]; then
            echo 'Version metadata is missing' >&2
            exit 1
          fi
          if [ -n "$TESTFLIGHT_PUBLIC_LINK" ]; then
            TF_VALUE="[Open TestFlight]($TESTFLIGHT_PUBLIC_LINK)"
          else
            TF_VALUE="公開リンク未設定（secrets.TESTFLIGHT_PUBLIC_LINK に共有URLを設定してください）"
          fi
          TITLE="TestFlight リリースがアップロードされました"
          PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg branch "$GITHUB_REF_NAME" \
            --arg commit "$COMMIT_SHORT" \
            --arg actor "$GITHUB_ACTOR" \
            --arg run "$RUN_URL" \
            --arg commitUrl "$COMMIT_URL" \
            --arg version "$VERSION" \
            --arg build "$BUILD" \
            --arg tf "$TF_VALUE" \
            '{
              embeds: [
                {
                  title: $title,
                  description: "[Actions Run](\($run)) · [Commit](\($commitUrl))",
                  color: 3447003,
                  fields: [
                    {name: "Branch", value: $branch, inline: true},
                    {name: "Actor", value: $actor, inline: true},
                    {name: "Commit", value: $commit, inline: true},
                    {name: "Version", value: $version, inline: true},
                    {name: "Build", value: $build, inline: true},
                    {name: "TestFlight", value: $tf, inline: false}
                  ],
                  footer: {text: "App Store Connect / TestFlight"}
                }
              ]
            }')
          curl -X POST -H 'Content-Type: application/json' -d "$PAYLOAD" "$WEBHOOK_URL"

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
